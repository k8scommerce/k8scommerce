package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
)

// OptionItem represents a row from 'public.option_item'.
type OptionItem struct {
	ID          int64  `json:"id" db:"id"`                     // id
	OptionID    int64  `json:"option_id" db:"option_id"`       // option_id
	Name        string `json:"name" db:"name"`                 // name
	DisplayName string `json:"display_name" db:"display_name"` // display_name
	SortOrder   int    `json:"sort_order" db:"sort_order"`     // sort_order
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the OptionItem exists in the database.
func (oi *OptionItem) Exists() bool {
	return oi._exists
}

// Deleted returns true when the OptionItem has been marked for deletion from
// the database.
func (oi *OptionItem) Deleted() bool {
	return oi._deleted
}

// Insert inserts the OptionItem to the database.
func (oi *OptionItem) Insert(ctx context.Context, db DB) error {
	switch {
	case oi._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case oi._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO public.option_item (` +
		`option_id, name, display_name, sort_order` +
		`) VALUES (` +
		`$1, $2, $3, $4` +
		`) RETURNING id`
	// run
	logf(sqlstr, oi.OptionID, oi.Name, oi.DisplayName, oi.SortOrder)
	if err := db.QueryRowContext(ctx, sqlstr, oi.OptionID, oi.Name, oi.DisplayName, oi.SortOrder).Scan(&oi.ID); err != nil {
		return logerror(err)
	}
	// set exists
	oi._exists = true
	return nil
}

// Update updates a OptionItem in the database.
func (oi *OptionItem) Update(ctx context.Context, db DB) error {
	switch {
	case !oi._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case oi._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.option_item SET ` +
		`option_id = $1, name = $2, display_name = $3, sort_order = $4 ` +
		`WHERE id = $5`
	// run
	logf(sqlstr, oi.OptionID, oi.Name, oi.DisplayName, oi.SortOrder, oi.ID)
	if _, err := db.ExecContext(ctx, sqlstr, oi.OptionID, oi.Name, oi.DisplayName, oi.SortOrder, oi.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the OptionItem to the database.
func (oi *OptionItem) Save(ctx context.Context, db DB) error {
	if oi.Exists() {
		return oi.Update(ctx, db)
	}
	return oi.Insert(ctx, db)
}

// Upsert performs an upsert for OptionItem.
func (oi *OptionItem) Upsert(ctx context.Context, db DB) error {
	switch {
	case oi._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.option_item (` +
		`id, option_id, name, display_name, sort_order` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`option_id = EXCLUDED.option_id, name = EXCLUDED.name, display_name = EXCLUDED.display_name, sort_order = EXCLUDED.sort_order `
	// run
	logf(sqlstr, oi.ID, oi.OptionID, oi.Name, oi.DisplayName, oi.SortOrder)
	if _, err := db.ExecContext(ctx, sqlstr, oi.ID, oi.OptionID, oi.Name, oi.DisplayName, oi.SortOrder); err != nil {
		return logerror(err)
	}
	// set exists
	oi._exists = true
	return nil
}

// Delete deletes the OptionItem from the database.
func (oi *OptionItem) Delete(ctx context.Context, db DB) error {
	switch {
	case !oi._exists: // doesn't exist
		return nil
	case oi._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.option_item ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, oi.ID)
	if _, err := db.ExecContext(ctx, sqlstr, oi.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	oi._deleted = true
	return nil
}

// OptionItemByName retrieves a row from 'public.option_item' as a OptionItem.
//
// Generated from index 'option_item_name_key'.
func OptionItemByName(ctx context.Context, db DB, name string) (*OptionItem, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, option_id, name, display_name, sort_order ` +
		`FROM public.option_item ` +
		`WHERE name = $1`
	// run
	logf(sqlstr, name)
	oi := OptionItem{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, name).Scan(&oi.ID, &oi.OptionID, &oi.Name, &oi.DisplayName, &oi.SortOrder); err != nil {
		return nil, logerror(err)
	}
	return &oi, nil
}

// OptionItemByID retrieves a row from 'public.option_item' as a OptionItem.
//
// Generated from index 'option_item_pkey'.
func OptionItemByID(ctx context.Context, db DB, id int64) (*OptionItem, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, option_id, name, display_name, sort_order ` +
		`FROM public.option_item ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, id)
	oi := OptionItem{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&oi.ID, &oi.OptionID, &oi.Name, &oi.DisplayName, &oi.SortOrder); err != nil {
		return nil, logerror(err)
	}
	return &oi, nil
}

// Option returns the Option associated with the OptionItem's (OptionID).
//
// Generated from foreign key 'option_item_option_id_fkey'.
func (oi *OptionItem) Option(ctx context.Context, db DB) (*Option, error) {
	return OptionByID(ctx, db, oi.OptionID)
}
