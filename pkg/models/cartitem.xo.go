package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"time"
)

// CartItem represents a row from 'public.cart_item'.
type CartItem struct {
	UserID      int64        `json:"user_id" db:"user_id"`           // user_id
	Sku         string       `json:"sku" db:"sku"`                   // sku
	Quantity    int          `json:"quantity" db:"quantity"`         // quantity
	Price       int64        `json:"price" db:"price"`               // price
	ExpiresAt   time.Time    `json:"expires_at" db:"expires_at"`     // expires_at
	AbandonedAt sql.NullTime `json:"abandoned_at" db:"abandoned_at"` // abandoned_at
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the CartItem exists in the database.
func (ci *CartItem) Exists() bool {
	return ci._exists
}

// Deleted returns true when the CartItem has been marked for deletion from
// the database.
func (ci *CartItem) Deleted() bool {
	return ci._deleted
}

// Insert inserts the CartItem to the database.
func (ci *CartItem) Insert(ctx context.Context, db DB) error {
	switch {
	case ci._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case ci._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO public.cart_item (` +
		`user_id, sku, quantity, price, expires_at, abandoned_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6` +
		`)`
	// run
	logf(sqlstr, ci.UserID, ci.Sku, ci.Quantity, ci.Price, ci.ExpiresAt, ci.AbandonedAt)
	if _, err := db.ExecContext(ctx, sqlstr, ci.UserID, ci.Sku, ci.Quantity, ci.Price, ci.ExpiresAt, ci.AbandonedAt); err != nil {
		return logerror(err)
	}
	// set exists
	ci._exists = true
	return nil
}

// Update updates a CartItem in the database.
func (ci *CartItem) Update(ctx context.Context, db DB) error {
	switch {
	case !ci._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case ci._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.cart_item SET ` +
		`quantity = $1, price = $2, expires_at = $3, abandoned_at = $4 ` +
		`WHERE user_id = $5 AND sku = $6`
	// run
	logf(sqlstr, ci.Quantity, ci.Price, ci.ExpiresAt, ci.AbandonedAt, ci.UserID, ci.Sku)
	if _, err := db.ExecContext(ctx, sqlstr, ci.Quantity, ci.Price, ci.ExpiresAt, ci.AbandonedAt, ci.UserID, ci.Sku); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the CartItem to the database.
func (ci *CartItem) Save(ctx context.Context, db DB) error {
	if ci.Exists() {
		return ci.Update(ctx, db)
	}
	return ci.Insert(ctx, db)
}

// Upsert performs an upsert for CartItem.
func (ci *CartItem) Upsert(ctx context.Context, db DB) error {
	switch {
	case ci._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.cart_item (` +
		`user_id, sku, quantity, price, expires_at, abandoned_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6` +
		`)` +
		` ON CONFLICT (user_id, sku) DO ` +
		`UPDATE SET ` +
		`quantity = EXCLUDED.quantity, price = EXCLUDED.price, expires_at = EXCLUDED.expires_at, abandoned_at = EXCLUDED.abandoned_at `
	// run
	logf(sqlstr, ci.UserID, ci.Sku, ci.Quantity, ci.Price, ci.ExpiresAt, ci.AbandonedAt)
	if _, err := db.ExecContext(ctx, sqlstr, ci.UserID, ci.Sku, ci.Quantity, ci.Price, ci.ExpiresAt, ci.AbandonedAt); err != nil {
		return logerror(err)
	}
	// set exists
	ci._exists = true
	return nil
}

// Delete deletes the CartItem from the database.
func (ci *CartItem) Delete(ctx context.Context, db DB) error {
	switch {
	case !ci._exists: // doesn't exist
		return nil
	case ci._deleted: // deleted
		return nil
	}
	// delete with composite primary key
	const sqlstr = `DELETE FROM public.cart_item ` +
		`WHERE user_id = $1 AND sku = $2`
	// run
	logf(sqlstr, ci.UserID, ci.Sku)
	if _, err := db.ExecContext(ctx, sqlstr, ci.UserID, ci.Sku); err != nil {
		return logerror(err)
	}
	// set deleted
	ci._deleted = true
	return nil
}

// CartItemByUserIDSku retrieves a row from 'public.cart_item' as a CartItem.
//
// Generated from index 'cart_item_pkey'.
func CartItemByUserIDSku(ctx context.Context, db DB, userID int64, sku string) (*CartItem, error) {
	// query
	const sqlstr = `SELECT ` +
		`user_id, sku, quantity, price, expires_at, abandoned_at ` +
		`FROM public.cart_item ` +
		`WHERE user_id = $1 AND sku = $2`
	// run
	logf(sqlstr, userID, sku)
	ci := CartItem{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, userID, sku).Scan(&ci.UserID, &ci.Sku, &ci.Quantity, &ci.Price, &ci.ExpiresAt, &ci.AbandonedAt); err != nil {
		return nil, logerror(err)
	}
	return &ci, nil
}

// Variant returns the Variant associated with the CartItem's (Sku).
//
// Generated from foreign key 'cart_item_sku_fkey'.
func (ci *CartItem) Variant(ctx context.Context, db DB) (*Variant, error) {
	return VariantBySku(ctx, db, ci.Sku)
}

// Cart returns the Cart associated with the CartItem's (UserID).
//
// Generated from foreign key 'cart_item_user_id_fkey'.
func (ci *CartItem) Cart(ctx context.Context, db DB) (*Cart, error) {
	return CartByUserID(ctx, db, ci.UserID)
}
