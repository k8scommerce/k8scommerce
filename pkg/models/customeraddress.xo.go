package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
)

// CustomerAddress represents a row from 'public.customer_address'.
type CustomerAddress struct {
	ID            int64       `json:"id" db:"id"`                         // id
	Kind          AddressKind `json:"kind" db:"kind"`                     // kind
	IsDefault     bool        `json:"is_default" db:"is_default"`         // is_default
	Street        string      `json:"street" db:"street"`                 // street
	City          string      `json:"city" db:"city"`                     // city
	StateProvince string      `json:"state_province" db:"state_province"` // state_province
	Country       string      `json:"country" db:"country"`               // country
	PostalCode    string      `json:"postal_code" db:"postal_code"`       // postal_code
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the CustomerAddress exists in the database.
func (ca *CustomerAddress) Exists() bool {
	return ca._exists
}

// Deleted returns true when the CustomerAddress has been marked for deletion from
// the database.
func (ca *CustomerAddress) Deleted() bool {
	return ca._deleted
}

// Insert inserts the CustomerAddress to the database.
func (ca *CustomerAddress) Insert(ctx context.Context, db DB) error {
	switch {
	case ca._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case ca._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO public.customer_address (` +
		`kind, is_default, street, city, state_province, country, postal_code` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7` +
		`) RETURNING id`
	// run
	logf(sqlstr, ca.Kind, ca.IsDefault, ca.Street, ca.City, ca.StateProvince, ca.Country, ca.PostalCode)
	if err := db.QueryRowContext(ctx, sqlstr, ca.Kind, ca.IsDefault, ca.Street, ca.City, ca.StateProvince, ca.Country, ca.PostalCode).Scan(&ca.ID); err != nil {
		return logerror(err)
	}
	// set exists
	ca._exists = true
	return nil
}

// Update updates a CustomerAddress in the database.
func (ca *CustomerAddress) Update(ctx context.Context, db DB) error {
	switch {
	case !ca._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case ca._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.customer_address SET ` +
		`kind = $1, is_default = $2, street = $3, city = $4, state_province = $5, country = $6, postal_code = $7 ` +
		`WHERE id = $8`
	// run
	logf(sqlstr, ca.Kind, ca.IsDefault, ca.Street, ca.City, ca.StateProvince, ca.Country, ca.PostalCode, ca.ID)
	if _, err := db.ExecContext(ctx, sqlstr, ca.Kind, ca.IsDefault, ca.Street, ca.City, ca.StateProvince, ca.Country, ca.PostalCode, ca.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the CustomerAddress to the database.
func (ca *CustomerAddress) Save(ctx context.Context, db DB) error {
	if ca.Exists() {
		return ca.Update(ctx, db)
	}
	return ca.Insert(ctx, db)
}

// Upsert performs an upsert for CustomerAddress.
func (ca *CustomerAddress) Upsert(ctx context.Context, db DB) error {
	switch {
	case ca._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.customer_address (` +
		`id, kind, is_default, street, city, state_province, country, postal_code` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`kind = EXCLUDED.kind, is_default = EXCLUDED.is_default, street = EXCLUDED.street, city = EXCLUDED.city, state_province = EXCLUDED.state_province, country = EXCLUDED.country, postal_code = EXCLUDED.postal_code `
	// run
	logf(sqlstr, ca.ID, ca.Kind, ca.IsDefault, ca.Street, ca.City, ca.StateProvince, ca.Country, ca.PostalCode)
	if _, err := db.ExecContext(ctx, sqlstr, ca.ID, ca.Kind, ca.IsDefault, ca.Street, ca.City, ca.StateProvince, ca.Country, ca.PostalCode); err != nil {
		return logerror(err)
	}
	// set exists
	ca._exists = true
	return nil
}

// Delete deletes the CustomerAddress from the database.
func (ca *CustomerAddress) Delete(ctx context.Context, db DB) error {
	switch {
	case !ca._exists: // doesn't exist
		return nil
	case ca._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.customer_address ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, ca.ID)
	if _, err := db.ExecContext(ctx, sqlstr, ca.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	ca._deleted = true
	return nil
}

// CustomerAddressByID retrieves a row from 'public.customer_address' as a CustomerAddress.
//
// Generated from index 'customer_address_pkey'.
func CustomerAddressByID(ctx context.Context, db DB, id int64) (*CustomerAddress, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, kind, is_default, street, city, state_province, country, postal_code ` +
		`FROM public.customer_address ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, id)
	ca := CustomerAddress{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&ca.ID, &ca.Kind, &ca.IsDefault, &ca.Street, &ca.City, &ca.StateProvince, &ca.Country, &ca.PostalCode); err != nil {
		return nil, logerror(err)
	}
	return &ca, nil
}
