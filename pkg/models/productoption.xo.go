package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
)

// ProductOption represents a row from 'public.product_option'.
type ProductOption struct {
	ProductID int64 `json:"product_id" db:"product_id"` // product_id
	OptionID  int64 `json:"option_id" db:"option_id"`   // option_id
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the ProductOption exists in the database.
func (po *ProductOption) Exists() bool {
	return po._exists
}

// Deleted returns true when the ProductOption has been marked for deletion from
// the database.
func (po *ProductOption) Deleted() bool {
	return po._deleted
}

// Insert inserts the ProductOption to the database.
func (po *ProductOption) Insert(ctx context.Context, db DB) error {
	switch {
	case po._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case po._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO public.product_option (` +
		`product_id, option_id` +
		`) VALUES (` +
		`$1, $2` +
		`)`
	// run
	logf(sqlstr, po.ProductID, po.OptionID)
	if _, err := db.ExecContext(ctx, sqlstr, po.ProductID, po.OptionID); err != nil {
		return logerror(err)
	}
	// set exists
	po._exists = true
	return nil
}

// ------ NOTE: Update statements omitted due to lack of fields other than primary key ------

// Delete deletes the ProductOption from the database.
func (po *ProductOption) Delete(ctx context.Context, db DB) error {
	switch {
	case !po._exists: // doesn't exist
		return nil
	case po._deleted: // deleted
		return nil
	}
	// delete with composite primary key
	const sqlstr = `DELETE FROM public.product_option ` +
		`WHERE product_id = $1 AND option_id = $2`
	// run
	logf(sqlstr, po.ProductID, po.OptionID)
	if _, err := db.ExecContext(ctx, sqlstr, po.ProductID, po.OptionID); err != nil {
		return logerror(err)
	}
	// set deleted
	po._deleted = true
	return nil
}

// ProductOptionByProductIDOptionID retrieves a row from 'public.product_option' as a ProductOption.
//
// Generated from index 'product_option_pkey'.
func ProductOptionByProductIDOptionID(ctx context.Context, db DB, productID, optionID int64) (*ProductOption, error) {
	// query
	const sqlstr = `SELECT ` +
		`product_id, option_id ` +
		`FROM public.product_option ` +
		`WHERE product_id = $1 AND option_id = $2`
	// run
	logf(sqlstr, productID, optionID)
	po := ProductOption{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, productID, optionID).Scan(&po.ProductID, &po.OptionID); err != nil {
		return nil, logerror(err)
	}
	return &po, nil
}

// Option returns the Option associated with the ProductOption's (OptionID).
//
// Generated from foreign key 'product_option_option_id_fkey'.
func (po *ProductOption) Option(ctx context.Context, db DB) (*Option, error) {
	return OptionByID(ctx, db, po.OptionID)
}

// Product returns the Product associated with the ProductOption's (ProductID).
//
// Generated from foreign key 'product_option_product_id_fkey'.
func (po *ProductOption) Product(ctx context.Context, db DB) (*Product, error) {
	return ProductByID(ctx, db, po.ProductID)
}
