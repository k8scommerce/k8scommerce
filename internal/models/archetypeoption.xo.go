package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
)

// ArchetypeOption represents a row from 'public.archetype_option'.
type ArchetypeOption struct {
	ArchetypeID int64 `json:"archetype_id" db:"archetype_id"` // archetype_id
	OptionID    int64 `json:"option_id" db:"option_id"`       // option_id
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the ArchetypeOption exists in the database.
func (ao *ArchetypeOption) Exists() bool {
	return ao._exists
}

// Deleted returns true when the ArchetypeOption has been marked for deletion from
// the database.
func (ao *ArchetypeOption) Deleted() bool {
	return ao._deleted
}

// Insert inserts the ArchetypeOption to the database.
func (ao *ArchetypeOption) Insert(ctx context.Context, db DB) error {
	switch {
	case ao._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case ao._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO public.archetype_option (` +
		`archetype_id, option_id` +
		`) VALUES (` +
		`$1, $2` +
		`)`
	// run
	logf(sqlstr, ao.ArchetypeID, ao.OptionID)
	if _, err := db.ExecContext(ctx, sqlstr, ao.ArchetypeID, ao.OptionID); err != nil {
		return logerror(err)
	}
	// set exists
	ao._exists = true
	return nil
}

// ------ NOTE: Update statements omitted due to lack of fields other than primary key ------

// Delete deletes the ArchetypeOption from the database.
func (ao *ArchetypeOption) Delete(ctx context.Context, db DB) error {
	switch {
	case !ao._exists: // doesn't exist
		return nil
	case ao._deleted: // deleted
		return nil
	}
	// delete with composite primary key
	const sqlstr = `DELETE FROM public.archetype_option ` +
		`WHERE archetype_id = $1 AND option_id = $2`
	// run
	logf(sqlstr, ao.ArchetypeID, ao.OptionID)
	if _, err := db.ExecContext(ctx, sqlstr, ao.ArchetypeID, ao.OptionID); err != nil {
		return logerror(err)
	}
	// set deleted
	ao._deleted = true
	return nil
}

// ArchetypeOptionByArchetypeIDOptionID retrieves a row from 'public.archetype_option' as a ArchetypeOption.
//
// Generated from index 'archetype_option_pkey'.
func ArchetypeOptionByArchetypeIDOptionID(ctx context.Context, db DB, archetypeID, optionID int64) (*ArchetypeOption, error) {
	// query
	const sqlstr = `SELECT ` +
		`archetype_id, option_id ` +
		`FROM public.archetype_option ` +
		`WHERE archetype_id = $1 AND option_id = $2`
	// run
	logf(sqlstr, archetypeID, optionID)
	ao := ArchetypeOption{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, archetypeID, optionID).Scan(&ao.ArchetypeID, &ao.OptionID); err != nil {
		return nil, logerror(err)
	}
	return &ao, nil
}

// Archetype returns the Archetype associated with the ArchetypeOption's (ArchetypeID).
//
// Generated from foreign key 'archetype_option_archetype_id_fkey'.
func (ao *ArchetypeOption) Archetype(ctx context.Context, db DB) (*Archetype, error) {
	return ArchetypeByID(ctx, db, ao.ArchetypeID)
}

// Option returns the Option associated with the ArchetypeOption's (OptionID).
//
// Generated from foreign key 'archetype_option_option_id_fkey'.
func (ao *ArchetypeOption) Option(ctx context.Context, db DB) (*Option, error) {
	return OptionByID(ctx, db, ao.OptionID)
}
