package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
)

// InventoryItem represents a row from 'public.inventory_item'.
type InventoryItem struct {
	ID         int64  `json:"id" db:"id"`                   // id
	StoreID    int64  `json:"store_id" db:"store_id"`       // store_id
	Sku        string `json:"sku" db:"sku"`                 // sku
	Name       string `json:"name" db:"name"`               // name
	SupplierID int64  `json:"supplier_id" db:"supplier_id"` // supplier_id
	BrandID    int64  `json:"brand_id" db:"brand_id"`       // brand_id
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the InventoryItem exists in the database.
func (ii *InventoryItem) Exists() bool {
	return ii._exists
}

// Deleted returns true when the InventoryItem has been marked for deletion from
// the database.
func (ii *InventoryItem) Deleted() bool {
	return ii._deleted
}

// Insert inserts the InventoryItem to the database.
func (ii *InventoryItem) Insert(ctx context.Context, db DB) error {
	switch {
	case ii._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case ii._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO public.inventory_item (` +
		`store_id, sku, name, supplier_id, brand_id` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5` +
		`) RETURNING id`
	// run
	logf(sqlstr, ii.StoreID, ii.Sku, ii.Name, ii.SupplierID, ii.BrandID)
	if err := db.QueryRowContext(ctx, sqlstr, ii.StoreID, ii.Sku, ii.Name, ii.SupplierID, ii.BrandID).Scan(&ii.ID); err != nil {
		return logerror(err)
	}
	// set exists
	ii._exists = true
	return nil
}

// Update updates a InventoryItem in the database.
func (ii *InventoryItem) Update(ctx context.Context, db DB) error {
	switch {
	case !ii._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case ii._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.inventory_item SET ` +
		`store_id = $1, sku = $2, name = $3, supplier_id = $4, brand_id = $5 ` +
		`WHERE id = $6`
	// run
	logf(sqlstr, ii.StoreID, ii.Sku, ii.Name, ii.SupplierID, ii.BrandID, ii.ID)
	if _, err := db.ExecContext(ctx, sqlstr, ii.StoreID, ii.Sku, ii.Name, ii.SupplierID, ii.BrandID, ii.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the InventoryItem to the database.
func (ii *InventoryItem) Save(ctx context.Context, db DB) error {
	if ii.Exists() {
		return ii.Update(ctx, db)
	}
	return ii.Insert(ctx, db)
}

// Upsert performs an upsert for InventoryItem.
func (ii *InventoryItem) Upsert(ctx context.Context, db DB) error {
	switch {
	case ii._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.inventory_item (` +
		`id, store_id, sku, name, supplier_id, brand_id` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`store_id = EXCLUDED.store_id, sku = EXCLUDED.sku, name = EXCLUDED.name, supplier_id = EXCLUDED.supplier_id, brand_id = EXCLUDED.brand_id `
	// run
	logf(sqlstr, ii.ID, ii.StoreID, ii.Sku, ii.Name, ii.SupplierID, ii.BrandID)
	if _, err := db.ExecContext(ctx, sqlstr, ii.ID, ii.StoreID, ii.Sku, ii.Name, ii.SupplierID, ii.BrandID); err != nil {
		return logerror(err)
	}
	// set exists
	ii._exists = true
	return nil
}

// Delete deletes the InventoryItem from the database.
func (ii *InventoryItem) Delete(ctx context.Context, db DB) error {
	switch {
	case !ii._exists: // doesn't exist
		return nil
	case ii._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.inventory_item ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, ii.ID)
	if _, err := db.ExecContext(ctx, sqlstr, ii.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	ii._deleted = true
	return nil
}

// InventoryItemByID retrieves a row from 'public.inventory_item' as a InventoryItem.
//
// Generated from index 'inventory_item_pkey'.
func InventoryItemByID(ctx context.Context, db DB, id int64) (*InventoryItem, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, store_id, sku, name, supplier_id, brand_id ` +
		`FROM public.inventory_item ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, id)
	ii := InventoryItem{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&ii.ID, &ii.StoreID, &ii.Sku, &ii.Name, &ii.SupplierID, &ii.BrandID); err != nil {
		return nil, logerror(err)
	}
	return &ii, nil
}
