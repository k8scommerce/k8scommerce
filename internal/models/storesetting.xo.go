package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
)

// StoreSetting represents a row from 'public.store_setting'.
type StoreSetting struct {
	ID      int64  `json:"id" db:"id"`             // id
	StoreID int64  `json:"store_id" db:"store_id"` // store_id
	Config  []byte `json:"config" db:"config"`     // config
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the StoreSetting exists in the database.
func (ss *StoreSetting) Exists() bool {
	return ss._exists
}

// Deleted returns true when the StoreSetting has been marked for deletion from
// the database.
func (ss *StoreSetting) Deleted() bool {
	return ss._deleted
}

// Insert inserts the StoreSetting to the database.
func (ss *StoreSetting) Insert(ctx context.Context, db DB) error {
	switch {
	case ss._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case ss._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO public.store_setting (` +
		`store_id, config` +
		`) VALUES (` +
		`$1, $2` +
		`) RETURNING id`
	// run
	logf(sqlstr, ss.StoreID, ss.Config)
	if err := db.QueryRowContext(ctx, sqlstr, ss.StoreID, ss.Config).Scan(&ss.ID); err != nil {
		return logerror(err)
	}
	// set exists
	ss._exists = true
	return nil
}

// Update updates a StoreSetting in the database.
func (ss *StoreSetting) Update(ctx context.Context, db DB) error {
	switch {
	case !ss._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case ss._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.store_setting SET ` +
		`store_id = $1, config = $2 ` +
		`WHERE id = $3`
	// run
	logf(sqlstr, ss.StoreID, ss.Config, ss.ID)
	if _, err := db.ExecContext(ctx, sqlstr, ss.StoreID, ss.Config, ss.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the StoreSetting to the database.
func (ss *StoreSetting) Save(ctx context.Context, db DB) error {
	if ss.Exists() {
		return ss.Update(ctx, db)
	}
	return ss.Insert(ctx, db)
}

// Upsert performs an upsert for StoreSetting.
func (ss *StoreSetting) Upsert(ctx context.Context, db DB) error {
	switch {
	case ss._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.store_setting (` +
		`id, store_id, config` +
		`) VALUES (` +
		`$1, $2, $3` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`store_id = EXCLUDED.store_id, config = EXCLUDED.config `
	// run
	logf(sqlstr, ss.ID, ss.StoreID, ss.Config)
	if _, err := db.ExecContext(ctx, sqlstr, ss.ID, ss.StoreID, ss.Config); err != nil {
		return logerror(err)
	}
	// set exists
	ss._exists = true
	return nil
}

// Delete deletes the StoreSetting from the database.
func (ss *StoreSetting) Delete(ctx context.Context, db DB) error {
	switch {
	case !ss._exists: // doesn't exist
		return nil
	case ss._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.store_setting ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, ss.ID)
	if _, err := db.ExecContext(ctx, sqlstr, ss.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	ss._deleted = true
	return nil
}

// StoreSettingByStoreID retrieves a row from 'public.store_setting' as a StoreSetting.
//
// Generated from index 'idx_store_settings_store_id'.
func StoreSettingByStoreID(ctx context.Context, db DB, storeID int64) ([]*StoreSetting, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, store_id, config ` +
		`FROM public.store_setting ` +
		`WHERE store_id = $1`
	// run
	logf(sqlstr, storeID)
	rows, err := db.QueryContext(ctx, sqlstr, storeID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*StoreSetting
	for rows.Next() {
		ss := StoreSetting{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&ss.ID, &ss.StoreID, &ss.Config); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &ss)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// StoreSettingByID retrieves a row from 'public.store_setting' as a StoreSetting.
//
// Generated from index 'store_setting_pkey'.
func StoreSettingByID(ctx context.Context, db DB, id int64) (*StoreSetting, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, store_id, config ` +
		`FROM public.store_setting ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, id)
	ss := StoreSetting{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&ss.ID, &ss.StoreID, &ss.Config); err != nil {
		return nil, logerror(err)
	}
	return &ss, nil
}

// Store returns the Store associated with the StoreSetting's (StoreID).
//
// Generated from foreign key 'store_setting_store_id_fkey'.
func (ss *StoreSetting) Store(ctx context.Context, db DB) (*Store, error) {
	return StoreByID(ctx, db, ss.StoreID)
}
