package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// Variant represents a row from 'public.variant'.
type Variant struct {
	ID                 int64           `json:"id" db:"id"`                                     // id
	ProductID          int64           `json:"product_id" db:"product_id"`                     // product_id
	IsDefault          bool            `json:"is_default" db:"is_default"`                     // is_default
	Sku                string          `json:"sku" db:"sku"`                                   // sku
	SortOrder          int             `json:"sort_order" db:"sort_order"`                     // sort_order
	CostAmount         sql.NullInt64   `json:"cost_amount" db:"cost_amount"`                   // cost_amount
	CostCurrency       sql.NullString  `json:"cost_currency" db:"cost_currency"`               // cost_currency
	TrackInventory     bool            `json:"track_inventory" db:"track_inventory"`           // track_inventory
	TaxCategoryID      sql.NullInt64   `json:"tax_category_id" db:"tax_category_id"`           // tax_category_id
	ShippingCategoryID sql.NullInt64   `json:"shipping_category_id" db:"shipping_category_id"` // shipping_category_id
	DiscontinueOn      sql.NullTime    `json:"discontinue_on" db:"discontinue_on"`             // discontinue_on
	Weight             sql.NullFloat64 `json:"weight" db:"weight"`                             // weight
	Height             sql.NullFloat64 `json:"height" db:"height"`                             // height
	Width              sql.NullFloat64 `json:"width" db:"width"`                               // width
	Depth              sql.NullFloat64 `json:"depth" db:"depth"`                               // depth
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the Variant exists in the database.
func (v *Variant) Exists() bool {
	return v._exists
}

// Deleted returns true when the Variant has been marked for deletion from
// the database.
func (v *Variant) Deleted() bool {
	return v._deleted
}

// Insert inserts the Variant to the database.
func (v *Variant) Insert(ctx context.Context, db DB) error {
	switch {
	case v._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case v._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO public.variant (` +
		`product_id, is_default, sku, sort_order, cost_amount, cost_currency, track_inventory, tax_category_id, shipping_category_id, discontinue_on, weight, height, width, depth` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14` +
		`) RETURNING id`
	// run
	logf(sqlstr, v.ProductID, v.IsDefault, v.Sku, v.SortOrder, v.CostAmount, v.CostCurrency, v.TrackInventory, v.TaxCategoryID, v.ShippingCategoryID, v.DiscontinueOn, v.Weight, v.Height, v.Width, v.Depth)
	if err := db.QueryRowContext(ctx, sqlstr, v.ProductID, v.IsDefault, v.Sku, v.SortOrder, v.CostAmount, v.CostCurrency, v.TrackInventory, v.TaxCategoryID, v.ShippingCategoryID, v.DiscontinueOn, v.Weight, v.Height, v.Width, v.Depth).Scan(&v.ID); err != nil {
		return logerror(err)
	}
	// set exists
	v._exists = true
	return nil
}

// Update updates a Variant in the database.
func (v *Variant) Update(ctx context.Context, db DB) error {
	switch {
	case !v._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case v._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.variant SET ` +
		`product_id = $1, is_default = $2, sku = $3, sort_order = $4, cost_amount = $5, cost_currency = $6, track_inventory = $7, tax_category_id = $8, shipping_category_id = $9, discontinue_on = $10, weight = $11, height = $12, width = $13, depth = $14 ` +
		`WHERE id = $15`
	// run
	logf(sqlstr, v.ProductID, v.IsDefault, v.Sku, v.SortOrder, v.CostAmount, v.CostCurrency, v.TrackInventory, v.TaxCategoryID, v.ShippingCategoryID, v.DiscontinueOn, v.Weight, v.Height, v.Width, v.Depth, v.ID)
	if _, err := db.ExecContext(ctx, sqlstr, v.ProductID, v.IsDefault, v.Sku, v.SortOrder, v.CostAmount, v.CostCurrency, v.TrackInventory, v.TaxCategoryID, v.ShippingCategoryID, v.DiscontinueOn, v.Weight, v.Height, v.Width, v.Depth, v.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the Variant to the database.
func (v *Variant) Save(ctx context.Context, db DB) error {
	if v.Exists() {
		return v.Update(ctx, db)
	}
	return v.Insert(ctx, db)
}

// Upsert performs an upsert for Variant.
func (v *Variant) Upsert(ctx context.Context, db DB) error {
	switch {
	case v._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.variant (` +
		`id, product_id, is_default, sku, sort_order, cost_amount, cost_currency, track_inventory, tax_category_id, shipping_category_id, discontinue_on, weight, height, width, depth` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`product_id = EXCLUDED.product_id, is_default = EXCLUDED.is_default, sku = EXCLUDED.sku, sort_order = EXCLUDED.sort_order, cost_amount = EXCLUDED.cost_amount, cost_currency = EXCLUDED.cost_currency, track_inventory = EXCLUDED.track_inventory, tax_category_id = EXCLUDED.tax_category_id, shipping_category_id = EXCLUDED.shipping_category_id, discontinue_on = EXCLUDED.discontinue_on, weight = EXCLUDED.weight, height = EXCLUDED.height, width = EXCLUDED.width, depth = EXCLUDED.depth `
	// run
	logf(sqlstr, v.ID, v.ProductID, v.IsDefault, v.Sku, v.SortOrder, v.CostAmount, v.CostCurrency, v.TrackInventory, v.TaxCategoryID, v.ShippingCategoryID, v.DiscontinueOn, v.Weight, v.Height, v.Width, v.Depth)
	if _, err := db.ExecContext(ctx, sqlstr, v.ID, v.ProductID, v.IsDefault, v.Sku, v.SortOrder, v.CostAmount, v.CostCurrency, v.TrackInventory, v.TaxCategoryID, v.ShippingCategoryID, v.DiscontinueOn, v.Weight, v.Height, v.Width, v.Depth); err != nil {
		return logerror(err)
	}
	// set exists
	v._exists = true
	return nil
}

// Delete deletes the Variant from the database.
func (v *Variant) Delete(ctx context.Context, db DB) error {
	switch {
	case !v._exists: // doesn't exist
		return nil
	case v._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.variant ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, v.ID)
	if _, err := db.ExecContext(ctx, sqlstr, v.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	v._deleted = true
	return nil
}

// VariantByIsDefault retrieves a row from 'public.variant' as a Variant.
//
// Generated from index 'idx_variant_is_default'.
func VariantByIsDefault(ctx context.Context, db DB, isDefault bool) ([]*Variant, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, product_id, is_default, sku, sort_order, cost_amount, cost_currency, track_inventory, tax_category_id, shipping_category_id, discontinue_on, weight, height, width, depth ` +
		`FROM public.variant ` +
		`WHERE is_default = $1`
	// run
	logf(sqlstr, isDefault)
	rows, err := db.QueryContext(ctx, sqlstr, isDefault)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Variant
	for rows.Next() {
		v := Variant{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&v.ID, &v.ProductID, &v.IsDefault, &v.Sku, &v.SortOrder, &v.CostAmount, &v.CostCurrency, &v.TrackInventory, &v.TaxCategoryID, &v.ShippingCategoryID, &v.DiscontinueOn, &v.Weight, &v.Height, &v.Width, &v.Depth); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &v)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// VariantByProductID retrieves a row from 'public.variant' as a Variant.
//
// Generated from index 'idx_variant_product_id'.
func VariantByProductID(ctx context.Context, db DB, productID int64) ([]*Variant, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, product_id, is_default, sku, sort_order, cost_amount, cost_currency, track_inventory, tax_category_id, shipping_category_id, discontinue_on, weight, height, width, depth ` +
		`FROM public.variant ` +
		`WHERE product_id = $1`
	// run
	logf(sqlstr, productID)
	rows, err := db.QueryContext(ctx, sqlstr, productID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Variant
	for rows.Next() {
		v := Variant{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&v.ID, &v.ProductID, &v.IsDefault, &v.Sku, &v.SortOrder, &v.CostAmount, &v.CostCurrency, &v.TrackInventory, &v.TaxCategoryID, &v.ShippingCategoryID, &v.DiscontinueOn, &v.Weight, &v.Height, &v.Width, &v.Depth); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &v)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// VariantByID retrieves a row from 'public.variant' as a Variant.
//
// Generated from index 'variant_pkey'.
func VariantByID(ctx context.Context, db DB, id int64) (*Variant, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, product_id, is_default, sku, sort_order, cost_amount, cost_currency, track_inventory, tax_category_id, shipping_category_id, discontinue_on, weight, height, width, depth ` +
		`FROM public.variant ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, id)
	v := Variant{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&v.ID, &v.ProductID, &v.IsDefault, &v.Sku, &v.SortOrder, &v.CostAmount, &v.CostCurrency, &v.TrackInventory, &v.TaxCategoryID, &v.ShippingCategoryID, &v.DiscontinueOn, &v.Weight, &v.Height, &v.Width, &v.Depth); err != nil {
		return nil, logerror(err)
	}
	return &v, nil
}

// VariantBySku retrieves a row from 'public.variant' as a Variant.
//
// Generated from index 'variant_sku_key'.
func VariantBySku(ctx context.Context, db DB, sku string) (*Variant, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, product_id, is_default, sku, sort_order, cost_amount, cost_currency, track_inventory, tax_category_id, shipping_category_id, discontinue_on, weight, height, width, depth ` +
		`FROM public.variant ` +
		`WHERE sku = $1`
	// run
	logf(sqlstr, sku)
	v := Variant{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, sku).Scan(&v.ID, &v.ProductID, &v.IsDefault, &v.Sku, &v.SortOrder, &v.CostAmount, &v.CostCurrency, &v.TrackInventory, &v.TaxCategoryID, &v.ShippingCategoryID, &v.DiscontinueOn, &v.Weight, &v.Height, &v.Width, &v.Depth); err != nil {
		return nil, logerror(err)
	}
	return &v, nil
}

// Product returns the Product associated with the Variant's (ProductID).
//
// Generated from foreign key 'variant_product_id_fkey'.
func (v *Variant) Product(ctx context.Context, db DB) (*Product, error) {
	return ProductByID(ctx, db, v.ProductID)
}
