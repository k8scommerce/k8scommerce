package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

// CartItem represents a row from 'public.cart_item'.
type CartItem struct {
	CartID      uuid.UUID      `json:"cart_id" db:"cart_id"`           // cart_id
	Sku         string         `json:"sku" db:"sku"`                   // sku
	Quantity    int            `json:"quantity" db:"quantity"`         // quantity
	Price       int64          `json:"price" db:"price"`               // price
	Currency    sql.NullString `json:"currency" db:"currency"`         // currency
	ExpiresAt   sql.NullTime   `json:"expires_at" db:"expires_at"`     // expires_at
	AbandonedAt sql.NullTime   `json:"abandoned_at" db:"abandoned_at"` // abandoned_at
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the CartItem exists in the database.
func (ci *CartItem) Exists() bool {
	return ci._exists
}

// Deleted returns true when the CartItem has been marked for deletion from
// the database.
func (ci *CartItem) Deleted() bool {
	return ci._deleted
}

// Insert inserts the CartItem to the database.
func (ci *CartItem) Insert(ctx context.Context, db DB) error {
	switch {
	case ci._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case ci._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO public.cart_item (` +
		`cart_id, sku, quantity, price, currency, expires_at, abandoned_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7` +
		`)`
	// run
	logf(sqlstr, ci.CartID, ci.Sku, ci.Quantity, ci.Price, ci.Currency, ci.ExpiresAt, ci.AbandonedAt)
	if _, err := db.ExecContext(ctx, sqlstr, ci.CartID, ci.Sku, ci.Quantity, ci.Price, ci.Currency, ci.ExpiresAt, ci.AbandonedAt); err != nil {
		return logerror(err)
	}
	// set exists
	ci._exists = true
	return nil
}

// Update updates a CartItem in the database.
func (ci *CartItem) Update(ctx context.Context, db DB) error {
	switch {
	case !ci._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case ci._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.cart_item SET ` +
		`quantity = $1, price = $2, currency = $3, expires_at = $4, abandoned_at = $5 ` +
		`WHERE cart_id = $6 AND sku = $7`
	// run
	logf(sqlstr, ci.Quantity, ci.Price, ci.Currency, ci.ExpiresAt, ci.AbandonedAt, ci.CartID, ci.Sku)
	if _, err := db.ExecContext(ctx, sqlstr, ci.Quantity, ci.Price, ci.Currency, ci.ExpiresAt, ci.AbandonedAt, ci.CartID, ci.Sku); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the CartItem to the database.
func (ci *CartItem) Save(ctx context.Context, db DB) error {
	if ci.Exists() {
		return ci.Update(ctx, db)
	}
	return ci.Insert(ctx, db)
}

// Upsert performs an upsert for CartItem.
func (ci *CartItem) Upsert(ctx context.Context, db DB) error {
	switch {
	case ci._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.cart_item (` +
		`cart_id, sku, quantity, price, currency, expires_at, abandoned_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7` +
		`)` +
		` ON CONFLICT (cart_id, sku) DO ` +
		`UPDATE SET ` +
		`quantity = EXCLUDED.quantity, price = EXCLUDED.price, currency = EXCLUDED.currency, expires_at = EXCLUDED.expires_at, abandoned_at = EXCLUDED.abandoned_at `
	// run
	logf(sqlstr, ci.CartID, ci.Sku, ci.Quantity, ci.Price, ci.Currency, ci.ExpiresAt, ci.AbandonedAt)
	if _, err := db.ExecContext(ctx, sqlstr, ci.CartID, ci.Sku, ci.Quantity, ci.Price, ci.Currency, ci.ExpiresAt, ci.AbandonedAt); err != nil {
		return logerror(err)
	}
	// set exists
	ci._exists = true
	return nil
}

// Delete deletes the CartItem from the database.
func (ci *CartItem) Delete(ctx context.Context, db DB) error {
	switch {
	case !ci._exists: // doesn't exist
		return nil
	case ci._deleted: // deleted
		return nil
	}
	// delete with composite primary key
	const sqlstr = `DELETE FROM public.cart_item ` +
		`WHERE cart_id = $1 AND sku = $2`
	// run
	logf(sqlstr, ci.CartID, ci.Sku)
	if _, err := db.ExecContext(ctx, sqlstr, ci.CartID, ci.Sku); err != nil {
		return logerror(err)
	}
	// set deleted
	ci._deleted = true
	return nil
}

// CartItemByCartIDSku retrieves a row from 'public.cart_item' as a CartItem.
//
// Generated from index 'cart_item_pkey'.
func CartItemByCartIDSku(ctx context.Context, db DB, cartID uuid.UUID, sku string) (*CartItem, error) {
	// query
	const sqlstr = `SELECT ` +
		`cart_id, sku, quantity, price, currency, expires_at, abandoned_at ` +
		`FROM public.cart_item ` +
		`WHERE cart_id = $1 AND sku = $2`
	// run
	logf(sqlstr, cartID, sku)
	ci := CartItem{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, cartID, sku).Scan(&ci.CartID, &ci.Sku, &ci.Quantity, &ci.Price, &ci.Currency, &ci.ExpiresAt, &ci.AbandonedAt); err != nil {
		return nil, logerror(err)
	}
	return &ci, nil
}

// CartItemByAbandonedAt retrieves a row from 'public.cart_item' as a CartItem.
//
// Generated from index 'idx_cart_item_abandoned_at'.
func CartItemByAbandonedAt(ctx context.Context, db DB, abandonedAt sql.NullTime) ([]*CartItem, error) {
	// query
	const sqlstr = `SELECT ` +
		`cart_id, sku, quantity, price, currency, expires_at, abandoned_at ` +
		`FROM public.cart_item ` +
		`WHERE abandoned_at = $1`
	// run
	logf(sqlstr, abandonedAt)
	rows, err := db.QueryContext(ctx, sqlstr, abandonedAt)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*CartItem
	for rows.Next() {
		ci := CartItem{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&ci.CartID, &ci.Sku, &ci.Quantity, &ci.Price, &ci.Currency, &ci.ExpiresAt, &ci.AbandonedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &ci)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// CartItemByCartID retrieves a row from 'public.cart_item' as a CartItem.
//
// Generated from index 'idx_cart_item_cart_id'.
func CartItemByCartID(ctx context.Context, db DB, cartID uuid.UUID) ([]*CartItem, error) {
	// query
	const sqlstr = `SELECT ` +
		`cart_id, sku, quantity, price, currency, expires_at, abandoned_at ` +
		`FROM public.cart_item ` +
		`WHERE cart_id = $1`
	// run
	logf(sqlstr, cartID)
	rows, err := db.QueryContext(ctx, sqlstr, cartID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*CartItem
	for rows.Next() {
		ci := CartItem{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&ci.CartID, &ci.Sku, &ci.Quantity, &ci.Price, &ci.Currency, &ci.ExpiresAt, &ci.AbandonedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &ci)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// CartItemBySku retrieves a row from 'public.cart_item' as a CartItem.
//
// Generated from index 'idx_cart_item_sku'.
func CartItemBySku(ctx context.Context, db DB, sku string) ([]*CartItem, error) {
	// query
	const sqlstr = `SELECT ` +
		`cart_id, sku, quantity, price, currency, expires_at, abandoned_at ` +
		`FROM public.cart_item ` +
		`WHERE sku = $1`
	// run
	logf(sqlstr, sku)
	rows, err := db.QueryContext(ctx, sqlstr, sku)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*CartItem
	for rows.Next() {
		ci := CartItem{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&ci.CartID, &ci.Sku, &ci.Quantity, &ci.Price, &ci.Currency, &ci.ExpiresAt, &ci.AbandonedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &ci)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// Cart returns the Cart associated with the CartItem's (CartID).
//
// Generated from foreign key 'cart_item_cart_id_fkey'.
func (ci *CartItem) Cart(ctx context.Context, db DB) (*Cart, error) {
	return CartByID(ctx, db, ci.CartID)
}

// Variant returns the Variant associated with the CartItem's (Sku).
//
// Generated from foreign key 'cart_item_sku_fkey'.
func (ci *CartItem) Variant(ctx context.Context, db DB) (*Variant, error) {
	return VariantBySku(ctx, db, ci.Sku)
}
