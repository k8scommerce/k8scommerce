package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
)

// CustomerAddress represents a row from 'public.customer_address'.
type CustomerAddress struct {
	ID            int64       `json:"id" db:"id"`                         // id
	StoreID       int64       `json:"store_id" db:"store_id"`             // store_id
	CustomerID    int64       `json:"customer_id" db:"customer_id"`       // customer_id
	Kind          AddressKind `json:"kind" db:"kind"`                     // kind
	IsDefault     bool        `json:"is_default" db:"is_default"`         // is_default
	Street        string      `json:"street" db:"street"`                 // street
	City          string      `json:"city" db:"city"`                     // city
	StateProvince string      `json:"state_province" db:"state_province"` // state_province
	Country       string      `json:"country" db:"country"`               // country
	PostalCode    string      `json:"postal_code" db:"postal_code"`       // postal_code
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the CustomerAddress exists in the database.
func (ca *CustomerAddress) Exists() bool {
	return ca._exists
}

// Deleted returns true when the CustomerAddress has been marked for deletion from
// the database.
func (ca *CustomerAddress) Deleted() bool {
	return ca._deleted
}

// Insert inserts the CustomerAddress to the database.
func (ca *CustomerAddress) Insert(ctx context.Context, db DB) error {
	switch {
	case ca._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case ca._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO public.customer_address (` +
		`store_id, customer_id, kind, is_default, street, city, state_province, country, postal_code` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9` +
		`) RETURNING id`
	// run
	logf(sqlstr, ca.StoreID, ca.CustomerID, ca.Kind, ca.IsDefault, ca.Street, ca.City, ca.StateProvince, ca.Country, ca.PostalCode)
	if err := db.QueryRowContext(ctx, sqlstr, ca.StoreID, ca.CustomerID, ca.Kind, ca.IsDefault, ca.Street, ca.City, ca.StateProvince, ca.Country, ca.PostalCode).Scan(&ca.ID); err != nil {
		return logerror(err)
	}
	// set exists
	ca._exists = true
	return nil
}

// Update updates a CustomerAddress in the database.
func (ca *CustomerAddress) Update(ctx context.Context, db DB) error {
	switch {
	case !ca._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case ca._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.customer_address SET ` +
		`store_id = $1, customer_id = $2, kind = $3, is_default = $4, street = $5, city = $6, state_province = $7, country = $8, postal_code = $9 ` +
		`WHERE id = $10`
	// run
	logf(sqlstr, ca.StoreID, ca.CustomerID, ca.Kind, ca.IsDefault, ca.Street, ca.City, ca.StateProvince, ca.Country, ca.PostalCode, ca.ID)
	if _, err := db.ExecContext(ctx, sqlstr, ca.StoreID, ca.CustomerID, ca.Kind, ca.IsDefault, ca.Street, ca.City, ca.StateProvince, ca.Country, ca.PostalCode, ca.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the CustomerAddress to the database.
func (ca *CustomerAddress) Save(ctx context.Context, db DB) error {
	if ca.Exists() {
		return ca.Update(ctx, db)
	}
	return ca.Insert(ctx, db)
}

// Upsert performs an upsert for CustomerAddress.
func (ca *CustomerAddress) Upsert(ctx context.Context, db DB) error {
	switch {
	case ca._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.customer_address (` +
		`id, store_id, customer_id, kind, is_default, street, city, state_province, country, postal_code` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`store_id = EXCLUDED.store_id, customer_id = EXCLUDED.customer_id, kind = EXCLUDED.kind, is_default = EXCLUDED.is_default, street = EXCLUDED.street, city = EXCLUDED.city, state_province = EXCLUDED.state_province, country = EXCLUDED.country, postal_code = EXCLUDED.postal_code `
	// run
	logf(sqlstr, ca.ID, ca.StoreID, ca.CustomerID, ca.Kind, ca.IsDefault, ca.Street, ca.City, ca.StateProvince, ca.Country, ca.PostalCode)
	if _, err := db.ExecContext(ctx, sqlstr, ca.ID, ca.StoreID, ca.CustomerID, ca.Kind, ca.IsDefault, ca.Street, ca.City, ca.StateProvince, ca.Country, ca.PostalCode); err != nil {
		return logerror(err)
	}
	// set exists
	ca._exists = true
	return nil
}

// Delete deletes the CustomerAddress from the database.
func (ca *CustomerAddress) Delete(ctx context.Context, db DB) error {
	switch {
	case !ca._exists: // doesn't exist
		return nil
	case ca._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.customer_address ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, ca.ID)
	if _, err := db.ExecContext(ctx, sqlstr, ca.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	ca._deleted = true
	return nil
}

// CustomerAddressByID retrieves a row from 'public.customer_address' as a CustomerAddress.
//
// Generated from index 'customer_address_pkey'.
func CustomerAddressByID(ctx context.Context, db DB, id int64) (*CustomerAddress, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, store_id, customer_id, kind, is_default, street, city, state_province, country, postal_code ` +
		`FROM public.customer_address ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, id)
	ca := CustomerAddress{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&ca.ID, &ca.StoreID, &ca.CustomerID, &ca.Kind, &ca.IsDefault, &ca.Street, &ca.City, &ca.StateProvince, &ca.Country, &ca.PostalCode); err != nil {
		return nil, logerror(err)
	}
	return &ca, nil
}

// CustomerAddressByCustomerID retrieves a row from 'public.customer_address' as a CustomerAddress.
//
// Generated from index 'idx_customer_customer_id'.
func CustomerAddressByCustomerID(ctx context.Context, db DB, customerID int64) ([]*CustomerAddress, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, store_id, customer_id, kind, is_default, street, city, state_province, country, postal_code ` +
		`FROM public.customer_address ` +
		`WHERE customer_id = $1`
	// run
	logf(sqlstr, customerID)
	rows, err := db.QueryContext(ctx, sqlstr, customerID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*CustomerAddress
	for rows.Next() {
		ca := CustomerAddress{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&ca.ID, &ca.StoreID, &ca.CustomerID, &ca.Kind, &ca.IsDefault, &ca.Street, &ca.City, &ca.StateProvince, &ca.Country, &ca.PostalCode); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &ca)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}
