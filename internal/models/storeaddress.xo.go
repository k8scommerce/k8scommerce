package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// StoreAddress represents a row from 'public.store_address'.
type StoreAddress struct {
	ID            int64          `json:"id" db:"id"`                         // id
	StoreID       int64          `json:"store_id" db:"store_id"`             // store_id
	Kind          AddressKind    `json:"kind" db:"kind"`                     // kind
	IsDefault     bool           `json:"is_default" db:"is_default"`         // is_default
	Address       sql.NullString `json:"address" db:"address"`               // address
	City          sql.NullString `json:"city" db:"city"`                     // city
	StateProvince sql.NullString `json:"state_province" db:"state_province"` // state_province
	PostalCode    sql.NullString `json:"postal_code" db:"postal_code"`       // postal_code
	Country       sql.NullString `json:"country" db:"country"`               // country
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the StoreAddress exists in the database.
func (sa *StoreAddress) Exists() bool {
	return sa._exists
}

// Deleted returns true when the StoreAddress has been marked for deletion from
// the database.
func (sa *StoreAddress) Deleted() bool {
	return sa._deleted
}

// Insert inserts the StoreAddress to the database.
func (sa *StoreAddress) Insert(ctx context.Context, db DB) error {
	switch {
	case sa._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case sa._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO public.store_address (` +
		`store_id, kind, is_default, address, city, state_province, postal_code, country` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8` +
		`) RETURNING id`
	// run
	logf(sqlstr, sa.StoreID, sa.Kind, sa.IsDefault, sa.Address, sa.City, sa.StateProvince, sa.PostalCode, sa.Country)
	if err := db.QueryRowContext(ctx, sqlstr, sa.StoreID, sa.Kind, sa.IsDefault, sa.Address, sa.City, sa.StateProvince, sa.PostalCode, sa.Country).Scan(&sa.ID); err != nil {
		return logerror(err)
	}
	// set exists
	sa._exists = true
	return nil
}

// Update updates a StoreAddress in the database.
func (sa *StoreAddress) Update(ctx context.Context, db DB) error {
	switch {
	case !sa._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case sa._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.store_address SET ` +
		`store_id = $1, kind = $2, is_default = $3, address = $4, city = $5, state_province = $6, postal_code = $7, country = $8 ` +
		`WHERE id = $9`
	// run
	logf(sqlstr, sa.StoreID, sa.Kind, sa.IsDefault, sa.Address, sa.City, sa.StateProvince, sa.PostalCode, sa.Country, sa.ID)
	if _, err := db.ExecContext(ctx, sqlstr, sa.StoreID, sa.Kind, sa.IsDefault, sa.Address, sa.City, sa.StateProvince, sa.PostalCode, sa.Country, sa.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the StoreAddress to the database.
func (sa *StoreAddress) Save(ctx context.Context, db DB) error {
	if sa.Exists() {
		return sa.Update(ctx, db)
	}
	return sa.Insert(ctx, db)
}

// Upsert performs an upsert for StoreAddress.
func (sa *StoreAddress) Upsert(ctx context.Context, db DB) error {
	switch {
	case sa._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.store_address (` +
		`id, store_id, kind, is_default, address, city, state_province, postal_code, country` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`store_id = EXCLUDED.store_id, kind = EXCLUDED.kind, is_default = EXCLUDED.is_default, address = EXCLUDED.address, city = EXCLUDED.city, state_province = EXCLUDED.state_province, postal_code = EXCLUDED.postal_code, country = EXCLUDED.country `
	// run
	logf(sqlstr, sa.ID, sa.StoreID, sa.Kind, sa.IsDefault, sa.Address, sa.City, sa.StateProvince, sa.PostalCode, sa.Country)
	if _, err := db.ExecContext(ctx, sqlstr, sa.ID, sa.StoreID, sa.Kind, sa.IsDefault, sa.Address, sa.City, sa.StateProvince, sa.PostalCode, sa.Country); err != nil {
		return logerror(err)
	}
	// set exists
	sa._exists = true
	return nil
}

// Delete deletes the StoreAddress from the database.
func (sa *StoreAddress) Delete(ctx context.Context, db DB) error {
	switch {
	case !sa._exists: // doesn't exist
		return nil
	case sa._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.store_address ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, sa.ID)
	if _, err := db.ExecContext(ctx, sqlstr, sa.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	sa._deleted = true
	return nil
}

// StoreAddressByID retrieves a row from 'public.store_address' as a StoreAddress.
//
// Generated from index 'store_address_pkey'.
func StoreAddressByID(ctx context.Context, db DB, id int64) (*StoreAddress, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, store_id, kind, is_default, address, city, state_province, postal_code, country ` +
		`FROM public.store_address ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, id)
	sa := StoreAddress{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&sa.ID, &sa.StoreID, &sa.Kind, &sa.IsDefault, &sa.Address, &sa.City, &sa.StateProvince, &sa.PostalCode, &sa.Country); err != nil {
		return nil, logerror(err)
	}
	return &sa, nil
}
