package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// PaymentTransaction represents a row from 'public.payment_transaction'.
type PaymentTransaction struct {
	ID            int64           `json:"id" db:"id"`                         // id
	StoreID       int64           `json:"store_id" db:"store_id"`             // store_id
	GatewayID     sql.NullInt64   `json:"gateway_id" db:"gateway_id"`         // gateway_id
	ReferenceCode string          `json:"reference_code" db:"reference_code"` // reference_code
	AuthCode      string          `json:"auth_code" db:"auth_code"`           // auth_code
	Response      string          `json:"response" db:"response"`             // response
	Amount        sql.NullInt64   `json:"amount" db:"amount"`                 // amount
	Currency      sql.NullString  `json:"currency" db:"currency"`             // currency
	Kind          TransactionKind `json:"kind" db:"kind"`                     // kind
	IsRecurring   sql.NullBool    `json:"is_recurring" db:"is_recurring"`     // is_recurring
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the PaymentTransaction exists in the database.
func (pt *PaymentTransaction) Exists() bool {
	return pt._exists
}

// Deleted returns true when the PaymentTransaction has been marked for deletion from
// the database.
func (pt *PaymentTransaction) Deleted() bool {
	return pt._deleted
}

// Insert inserts the PaymentTransaction to the database.
func (pt *PaymentTransaction) Insert(ctx context.Context, db DB) error {
	switch {
	case pt._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case pt._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO public.payment_transaction (` +
		`store_id, gateway_id, reference_code, auth_code, response, amount, currency, kind, is_recurring` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9` +
		`) RETURNING id`
	// run
	logf(sqlstr, pt.StoreID, pt.GatewayID, pt.ReferenceCode, pt.AuthCode, pt.Response, pt.Amount, pt.Currency, pt.Kind, pt.IsRecurring)
	if err := db.QueryRowContext(ctx, sqlstr, pt.StoreID, pt.GatewayID, pt.ReferenceCode, pt.AuthCode, pt.Response, pt.Amount, pt.Currency, pt.Kind, pt.IsRecurring).Scan(&pt.ID); err != nil {
		return logerror(err)
	}
	// set exists
	pt._exists = true
	return nil
}

// Update updates a PaymentTransaction in the database.
func (pt *PaymentTransaction) Update(ctx context.Context, db DB) error {
	switch {
	case !pt._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case pt._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.payment_transaction SET ` +
		`store_id = $1, gateway_id = $2, reference_code = $3, auth_code = $4, response = $5, amount = $6, currency = $7, kind = $8, is_recurring = $9 ` +
		`WHERE id = $10`
	// run
	logf(sqlstr, pt.StoreID, pt.GatewayID, pt.ReferenceCode, pt.AuthCode, pt.Response, pt.Amount, pt.Currency, pt.Kind, pt.IsRecurring, pt.ID)
	if _, err := db.ExecContext(ctx, sqlstr, pt.StoreID, pt.GatewayID, pt.ReferenceCode, pt.AuthCode, pt.Response, pt.Amount, pt.Currency, pt.Kind, pt.IsRecurring, pt.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the PaymentTransaction to the database.
func (pt *PaymentTransaction) Save(ctx context.Context, db DB) error {
	if pt.Exists() {
		return pt.Update(ctx, db)
	}
	return pt.Insert(ctx, db)
}

// Upsert performs an upsert for PaymentTransaction.
func (pt *PaymentTransaction) Upsert(ctx context.Context, db DB) error {
	switch {
	case pt._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.payment_transaction (` +
		`id, store_id, gateway_id, reference_code, auth_code, response, amount, currency, kind, is_recurring` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`store_id = EXCLUDED.store_id, gateway_id = EXCLUDED.gateway_id, reference_code = EXCLUDED.reference_code, auth_code = EXCLUDED.auth_code, response = EXCLUDED.response, amount = EXCLUDED.amount, currency = EXCLUDED.currency, kind = EXCLUDED.kind, is_recurring = EXCLUDED.is_recurring `
	// run
	logf(sqlstr, pt.ID, pt.StoreID, pt.GatewayID, pt.ReferenceCode, pt.AuthCode, pt.Response, pt.Amount, pt.Currency, pt.Kind, pt.IsRecurring)
	if _, err := db.ExecContext(ctx, sqlstr, pt.ID, pt.StoreID, pt.GatewayID, pt.ReferenceCode, pt.AuthCode, pt.Response, pt.Amount, pt.Currency, pt.Kind, pt.IsRecurring); err != nil {
		return logerror(err)
	}
	// set exists
	pt._exists = true
	return nil
}

// Delete deletes the PaymentTransaction from the database.
func (pt *PaymentTransaction) Delete(ctx context.Context, db DB) error {
	switch {
	case !pt._exists: // doesn't exist
		return nil
	case pt._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.payment_transaction ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, pt.ID)
	if _, err := db.ExecContext(ctx, sqlstr, pt.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	pt._deleted = true
	return nil
}

// PaymentTransactionByKind retrieves a row from 'public.payment_transaction' as a PaymentTransaction.
//
// Generated from index 'idx_payment_transaction_kind'.
func PaymentTransactionByKind(ctx context.Context, db DB, kind TransactionKind) ([]*PaymentTransaction, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, store_id, gateway_id, reference_code, auth_code, response, amount, currency, kind, is_recurring ` +
		`FROM public.payment_transaction ` +
		`WHERE kind = $1`
	// run
	logf(sqlstr, kind)
	rows, err := db.QueryContext(ctx, sqlstr, kind)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*PaymentTransaction
	for rows.Next() {
		pt := PaymentTransaction{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&pt.ID, &pt.StoreID, &pt.GatewayID, &pt.ReferenceCode, &pt.AuthCode, &pt.Response, &pt.Amount, &pt.Currency, &pt.Kind, &pt.IsRecurring); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &pt)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// PaymentTransactionByReferenceCode retrieves a row from 'public.payment_transaction' as a PaymentTransaction.
//
// Generated from index 'idx_payment_transaction_reference_code'.
func PaymentTransactionByReferenceCode(ctx context.Context, db DB, referenceCode string) ([]*PaymentTransaction, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, store_id, gateway_id, reference_code, auth_code, response, amount, currency, kind, is_recurring ` +
		`FROM public.payment_transaction ` +
		`WHERE reference_code = $1`
	// run
	logf(sqlstr, referenceCode)
	rows, err := db.QueryContext(ctx, sqlstr, referenceCode)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*PaymentTransaction
	for rows.Next() {
		pt := PaymentTransaction{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&pt.ID, &pt.StoreID, &pt.GatewayID, &pt.ReferenceCode, &pt.AuthCode, &pt.Response, &pt.Amount, &pt.Currency, &pt.Kind, &pt.IsRecurring); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &pt)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// PaymentTransactionByID retrieves a row from 'public.payment_transaction' as a PaymentTransaction.
//
// Generated from index 'payment_transaction_pkey'.
func PaymentTransactionByID(ctx context.Context, db DB, id int64) (*PaymentTransaction, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, store_id, gateway_id, reference_code, auth_code, response, amount, currency, kind, is_recurring ` +
		`FROM public.payment_transaction ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, id)
	pt := PaymentTransaction{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&pt.ID, &pt.StoreID, &pt.GatewayID, &pt.ReferenceCode, &pt.AuthCode, &pt.Response, &pt.Amount, &pt.Currency, &pt.Kind, &pt.IsRecurring); err != nil {
		return nil, logerror(err)
	}
	return &pt, nil
}
