package main

import (
	"context"
	"fmt"
	"k8scommerce/internal/models"
	"k8scommerce/internal/utils"
	"math/rand"
	"strings"

	"github.com/Pallinder/go-randomdata"
	"github.com/gosimple/slug"
	"github.com/iancoleman/strcase"
)

var (
	products                     Products = Products{}
	variantSelectedOptionsMap    map[string]bool
	variantSelectedPropertiesMap map[string]bool
)

type Products []models.Product

func (p *Products) Generate(categories Categories) *Products {
	for range categories {
		for i := 0; i < utils.RandInt(minProducts, maxProducts); i++ {

			name := fmt.Sprintf("%s %s %s", randomdata.SillyName(), randomdata.SillyName(), randomdata.SillyName())

			model := models.Product{
				StoreID:          1,
				Slug:             slug.Make(name),
				Name:             name,
				ShortDescription: toNullString(randomdata.Paragraph()),
				Description:      toNullString(fmt.Sprintf("<p>%s</p><p>%s</p><p>%s</p>", randomdata.Paragraph(), randomdata.Paragraph(), randomdata.Paragraph())),
				MetaTitle:        toNullString(name),
				MetaDescription:  toNullString(randomdata.Paragraph()),
				MetaKeywords:     toNullString(strings.Join(strings.Split(randomdata.Paragraph(), " "), ", ")),
			}

			if err := model.Insert(context.Background(), db); err != nil {
				fmt.Printf("ERROR: %s, %d\n", model.Name, model.ID)
				panic(err)
			}

			*p = append(*p, model)

			p.addStoreProductRelation(&model)
			p.addProductProperties(&model)
			p.createVariants(&model)
		}
	}

	repo.GetRawDB().Exec(`
		with cte as (
			select * from product
			order by random()
			limit 48
		)
		update product p 
		set featured = true
		from cte
		where p.id = cte.id`,
	)

	return p
}

func (p *Products) createVariants(product *models.Product) {
	// each product will have at least 1 variant
	// the variants will be auto-generated by which
	// options are selected. We will select these at random

	// reset the variantSelectedOptionsMap
	variantSelectedOptionsMap = make(map[string]bool)

	// start with getting 1 or more random options
	// used to generate the skus
	cartesianProductGroups := [][]string{}
	// optionNames := []string{}
	optionCount := utils.RandInt(1, len(options))
	for i := 0; i < int(optionCount); i++ {
		selectedIdx := p.validateOptionIdx(p.pick(options))
		// optionNames = append(optionNames, selectedIdx)
		// get an assortment of the options
		items := optionItems[options[selectedIdx]]
		totalItems := len(items)
		start := utils.RandInt(0, totalItems)
		if start >= (totalItems / 2) {
			start = start - (totalItems / 2)
		}
		end := utils.RandInt(start+1, totalItems)
		if end-start >= 4 {
			end = start + 4
		}

		itemSelection := items[start:end]
		selected := []string{}
		for _, t := range itemSelection {
			selected = append(selected, optionItemNames[t])
		}
		cartesianProductGroups = append(cartesianProductGroups, selected)
	}

	// create the variants
	// start with the default
	sortOrder := 1
	p.addVariant(product.ID, true, product.Slug, sortOrder)
	sortOrder++

	// now create the others
	for _, prod := range utils.CartesianProduct(cartesianProductGroups) {
		skuAppend := strcase.ToKebab(strings.Join(prod, "-"))
		variantSku := product.Slug + "-" + skuAppend
		variantSku = strings.ReplaceAll(variantSku, "/", "")
		variantSku = strings.ReplaceAll(variantSku, " ", "-")

		p.addVariant(product.ID, false, variantSku, sortOrder)
		sortOrder++
	}
}

func (p *Products) addVariant(productID int64, isDefault bool, sku string, sortOrder int) {

	record := &models.Variant{
		ProductID:      productID,
		IsDefault:      isDefault,
		Sku:            sku,
		CostAmount:     toNullInt64(int64(utils.RandInt(999, 10999))),
		CostCurrency:   toNullString("USD"),
		TrackInventory: true,
		SortOrder:      sortOrder,
	}
	if err := record.Insert(context.Background(), db); err != nil {
		panic(err)
	}

	p.addVariantPriceRelation(record)
}

func (p *Products) validateOptionIdx(idx string) string {
	if _, ok := variantSelectedOptionsMap[idx]; ok {
		idx := p.pick(options)
		return p.validateOptionIdx(idx)
	}
	variantSelectedOptionsMap[idx] = true
	return idx
}

func (p *Products) validatePropertyIdx(idx string) string {
	if _, ok := variantSelectedPropertiesMap[idx]; ok {
		idx := p.pick(properties)
		return p.validatePropertyIdx(idx)
	}
	variantSelectedPropertiesMap[idx] = true
	return idx
}

func (p *Products) addProductProperties(product *models.Product) {
	randPropertyCount := utils.RandInt(1, len(properties))
	// reset the variantSelectedPropertiesMap
	variantSelectedPropertiesMap = make(map[string]bool)
	for i := 0; i < int(randPropertyCount); i++ {
		selectedIdx := p.validatePropertyIdx(p.pick(properties))
		propertyID := properties[selectedIdx]
		if propertyID > 0 {
			p.addProductProperty(product.ID, propertyID)
		}
	}
}

func (p *Products) addProductProperty(productID, propertyID int64) {
	record := &models.ProductProperty{
		ProductID:  productID,
		PropertyID: propertyID,
	}
	if err := record.Insert(context.Background(), db); err != nil {
		panic(err)
	}
}

func (p *Products) addVariantPriceRelation(variant *models.Variant) {
	money1 := float64(variant.CostAmount.Int64) * utils.RandFloat(1.2, 3)
	money2 := float64(variant.CostAmount.Int64) * utils.RandFloat(3, 3.4)

	record := &models.Price{
		VariantID:   variant.ID,
		SalePrice:   int64(money1),
		Currency:    variant.CostCurrency,
		RetailPrice: toNullInt64(int64(money2)),
	}
	if err := record.Insert(context.Background(), db); err != nil {
		panic(err)
	}
}

func (p *Products) addStoreProductRelation(product *models.Product) {
	record := &models.StoreProduct{
		StoreID:   storeID,
		ProductID: product.ID,
	}
	if err := record.Insert(context.Background(), db); err != nil {
		panic(err)
	}
}

func (p *Products) pick(m map[string]int64) string {
	k := rand.Intn(len(m))
	for x := range m {
		if k == 0 {
			return x
		}
		k--
	}
	panic("unreachable")
}
